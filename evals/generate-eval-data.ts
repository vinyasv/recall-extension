#!/usr/bin/env tsx
/**
 * Generate eval-data.js used by the Chrome eval harness.
 *
 * This converts the canonical dataset from src/utils/evalData.ts into a
 * browser-friendly bundle that the chrome-eval.html page can load without
 * dynamic imports (which aren't allowed for file:// URLs in MV3).
 */

import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

import { TEST_PAGES, EVAL_QUERIES } from '../src/utils/evalData';

async function generate() {
  const rootDir = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '..');
  const publicDir = path.join(rootDir, 'public');
  const distDir = path.join(rootDir, 'dist');
  const htmlSourcePath = path.join(rootDir, 'evals', 'chrome-eval.html');
  const jsSourcePath = path.join(rootDir, 'evals', 'chrome-eval.js');

  const outputPath = path.join(publicDir, 'eval-data.js');
  const distEvalDataPath = path.join(distDir, 'eval-data.js');
  const distEvalHtmlPath = path.join(distDir, 'chrome-eval.html');
  const distEvalJsPath = path.join(distDir, 'chrome-eval.js');

  const header = `// Auto-generated by evals/generate-eval-data.ts. Do not edit manually.\n`;
  const payload = {
    testPages: TEST_PAGES,
    queries: EVAL_QUERIES,
  };

  const contents =
    `${header}\n` +
    `window.EVAL_DATA = ${JSON.stringify(payload, null, 2)};\n`;

  await fs.writeFile(outputPath, contents, 'utf-8');
  await fs.mkdir(distDir, { recursive: true });
  await fs.writeFile(distEvalDataPath, contents, 'utf-8');

  await fs.copyFile(htmlSourcePath, distEvalHtmlPath);
  await fs.copyFile(jsSourcePath, distEvalJsPath);

  console.log(`[eval-data] Wrote dataset to ${outputPath}`);
  console.log(`[eval-data] Wrote dataset to ${distEvalDataPath}`);
  console.log(`[eval-data] Copied chrome-eval.html to ${distEvalHtmlPath}`);
  console.log(`[eval-data] Copied chrome-eval.js to ${distEvalJsPath}`);
}

generate().catch(error => {
  console.error('[eval-data] Failed to generate dataset:', error);
  process.exit(1);
});

